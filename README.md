# OOD-Practice-2
#بخش1)
<h3>                                                                                                                                                                          Strategy</h3>

<ol>
    <li>
        در سیستم ما دو مورد وجود دارد که به روش‌های مختلفی انجام می‌شوند: مورد اول نحوه دریافت تیکت که بستگی به کانال ورودی دارد که می‌تواند از طریق وب یا ایمیل دریافت شود و مورد دوم نحوه پاسخ‌دهی است که به نوع تیکت (باگ یا درخواست عمومی) بستگی دارد. در کد اولیه، این‌ها با دستورات if-else از هم جدا شده بودند.
    </li>
    <li>
        الگوی Strategy: روش‌های مختلف برای پاسخ‌دهی داریم که روش‌های مختلف را در کلاس‌های جداگانه کپسوله می‌کنیم و اگر در آینده بخواهیم کانال جدیدی (مثل پیامک) یا نوع تیکت جدیدی اضافه کنیم، نیازی به تغییر در کدهای قبلی و بدنه اصلی سیستم نیست و فقط یک کلاس جدید می‌سازیم.
    </li>
    <li>
        اینترفیس به نام‌های ChannelStrategy و ResponseStrategy هر کدام جداگانه برای دو بخش مختلف تعریف می‌کنیم. برای هر روش یک کلاس جداگانه می‌سازیم. کلاس‌های WebChannelStrategy و EmailChannelStrategy برای بخش کانال، و کلاس‌های BugResponseStrategy و GenericResponseStrategy برای بخش پاسخ‌دهی. کلاس‌های State بدون اینکه بدانند نوع تیکت چیست فقط متد اجرای استراتژی را صدا می‌زنند.
    </li>
</ol>
<h3>Factory</h3>

<ol>
    <li>
        ایجاد یک آبجکت تیکت در سیستم ما پیچیده است چون تیکت بلافاصله بعد از ساخته شدن باید بداند از چه کانالی آمده و چه نوع استراتژی پاسخ‌دهی به آن تعلق می‌گیرد. اگر این کار را مستقیم در Main انجام دهیم در نتیجه منطق ساخت در کل برنامه پخش می‌شود.
    </li>
    <li>
        الگوی Factory: این الگو فرآیند ساخت آبجکت‌های پیچیده را کپسوله می‌کند. با این کار کلاینت درگیر جزئیات ساخت و ست کردن استراتژی‌ها نمی‌شود. همچنین باعث می‌شود که سیستم نسبت به نوع دقیق تیکت‌هایی که ساخته می‌شوند اطلاعی نداشته باشد و در نتیجه وابستگی‌ها کم شود.
    </li>
    <li>
        ابتدا یک کلاس انتزاعی Abstract به نام TicketFactory تعریف می‌کنیم که متد createTicket را دارد. سپس برای هر کانال ورودی، زیرمجموعه می‌سازیم WebTicketFactory و EmailTicketFactory. این فکتوری‌ها وظیفه دارند تیکت را بسازند، استراتژی کانال مربوطه را به آن منتقل کنند و با توجه به نوع تیکت استراتژی پاسخ‌دهی درست را هم درون تیکت قرار دهند و در نهایت یک تیکت نهایی تحویل بدهند.
    </li>
</ol>



<h3 style="text-align: right;">State</h3>

<ol style="direction: rtl; text-align: right;">
  <li>
    درخواست های پشتیبانی هرکدام چند وضعیت متوالی دارند. درخواست ابتدا ایجاد شده سپس به بخش مربوطه ارجاع داده می‌شود و تا زمانی که کامل حل شود، در حالت "در حال رسیدگی" خواهد بود. سپس حل شده و درخواست بسته می‌شود.
  </li>
  <li>
    شی درخواست، وضعیت داخلی ‌اش تغییر کرده و با توجه به حالتی که در آن است، رفتارش متفاوت است. پس میتوانیم با الگوی State این قسمت را بازطراحی کنیم.
  </li>
  <li>
    برای اعمال این الگو، ابتدا باید یک interface به نام RequestState میسازیم که یک تابع Next() و PrintStatus() دارد. سپس برای هر حالت، یک کلاس میسازیم که از این interface، implement میکنند. کلاس هایی با نام createdState، assignedState، inProgressState ، ResolvedState و closedState. هر کدام از این کلاس ها تابع Next() را تغییر داده و حالت بعدی را فراخوانی میکنند و با متد PrintStatus() حالت خود را چاپ میکنند. Context این الگو نیز، کلاس Ticket است.
  </li>
</ol>











#بخش2)
<h3>   


<img width="1289" height="681" alt="Untitled Diagram drawio (3)" src="https://github.com/user-attachments/assets/c61424fe-9a84-4558-904f-d2a9758706ff" />




#بخش3)  

<h3>  

<h3>اصل SRP</h3>
<ol>
    <li>
        کلاس <strong>TicketService</strong> در ابتدا اصل SRP را نقض می‌کرد؛ زیرا هم منطق بررسی وضعیت درخواست را بر عهده داشت و هم مدیریت انواع پاسخ‌ها و کانال‌ها را انجام می‌داد.
    </li>
    <li>
        این موضوع باعث می‌شد کلاس بیش از یک دلیل برای تغییر داشته باشد؛ مثلاً در صورت اضافه شدن وضعیت جدید، نوع پاسخ جدید یا کانال جدید.
    </li>
    <li>
        پس از اعمال تغییرات و استفاده از الگوهای <strong>State</strong> و <strong>Strategy</strong>، مسئولیت‌ها از یکدیگر جدا شدند و کلاس <strong>TicketService</strong> تنها یک دلیل برای تغییر دارد؛ در نتیجه اصل SRP رعایت شده است.
    </li>
</ol>

<h3>اصل LSP</h3>
<ol>
    <li>
        قبل از اعمال الگوها، به دلیل نبود abstraction مناسب، بررسی اصل LSP امکان‌پذیر نبود.
    </li>
    <li>
        پس از اضافه شدن interfaceها و abstraction، این اصل برقرار شده است.
    </li>
    <li>
        به عنوان مثال، هر جا که از نوع <strong>RequestState</strong> استفاده شده باشد، می‌توان بدون ایجاد رفتار غیرمنتظره، کلاس <strong>AssignedState</strong> را جایگزین کرد؛ زیرا تمام متدهای interface را پیاده‌سازی کرده و قرارداد آن را نقض نمی‌کند.
    </li>
</ol>

<h3>اصل ISP</h3>
<ol>
    <li>
        قبل از اعمال الگو، به دلیل نبود interface، اصل ISP قابل بررسی نبود.
    </li>
    <li>
        پس از اضافه شدن interfaceها، این اصل به‌صورت کلی رعایت شده است.
    </li>
    <li>
        اگرچه ممکن است برخی Stateها به متدهای <strong>Next</strong> یا <strong>PrintState</strong> نیازی نداشته باشند و در نگاه اول نقض ISP به نظر برسد،
        اما با توجه به سادگی الگوی State و ابعاد پروژه، این تصمیم آگاهانه بوده و نیازی به تفکیک interfaceها وجود ندارد.
    </li>
</ol>

<h3>اصل PLK (Least Knowledge)</h3>
<ol>
    <li>
        کلاس <strong>TicketService</strong> در ابتدا این اصل را نقض می‌کرد؛ زیرا وابستگی زیادی به جزئیات داخلی کلاس <strong>Ticket</strong> داشت.
    </li>
    <li>
        این کلاس مستقیماً از نام فیلدها، وضعیت‌ها، کانال‌ها و نوع پاسخ‌ها اطلاع داشت و منطق مربوط به آن‌ها را مدیریت می‌کرد.
    </li>
    <li>
        پس از اعمال الگوها، <strong>TicketService</strong> تنها از طریق متدهای سطح بالا با شیء <strong>Ticket</strong> تعامل می‌کند و دیگر از جزئیات داخلی آن اطلاعی ندارد؛
        در نتیجه وابستگی کاهش یافته و اصل PLK تا حد زیادی رعایت شده است.
    </li>
</ol>


