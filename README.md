# OOD-Practice-2
#بخش1)
<h3>                                                                                                                                                                          Strategy</h3>

<ol>
    <li>
        در سیستم ما دو مورد وجود دارد که به روش‌های مختلفی انجام می‌شوند: مورد اول نحوه دریافت تیکت که بستگی به کانال ورودی دارد که می‌تواند از طریق وب یا ایمیل دریافت شود و مورد دوم نحوه پاسخ‌دهی است که به نوع تیکت (باگ یا درخواست عمومی) بستگی دارد. در کد اولیه، این‌ها با دستورات if-else از هم جدا شده بودند.
    </li>
    <li>
        الگوی Strategy: روش‌های مختلف برای پاسخ‌دهی داریم که روش‌های مختلف را در کلاس‌های جداگانه کپسوله می‌کنیم و اگر در آینده بخواهیم کانال جدیدی (مثل پیامک) یا نوع تیکت جدیدی اضافه کنیم، نیازی به تغییر در کدهای قبلی و بدنه اصلی سیستم نیست و فقط یک کلاس جدید می‌سازیم.
    </li>
    <li>
        اینترفیس به نام‌های ChannelStrategy و ResponseStrategy هر کدام جداگانه برای دو بخش مختلف تعریف می‌کنیم. برای هر روش یک کلاس جداگانه می‌سازیم. کلاس‌های WebChannelStrategy و EmailChannelStrategy برای بخش کانال، و کلاس‌های BugResponseStrategy و GenericResponseStrategy برای بخش پاسخ‌دهی. کلاس‌های State بدون اینکه بدانند نوع تیکت چیست فقط متد اجرای استراتژی را صدا می‌زنند.
    </li>
</ol>
<h3>Factory</h3>

<ol>
    <li>
        ایجاد یک آبجکت تیکت در سیستم ما پیچیده است چون تیکت بلافاصله بعد از ساخته شدن باید بداند از چه کانالی آمده و چه نوع استراتژی پاسخ‌دهی به آن تعلق می‌گیرد. اگر این کار را مستقیم در Main انجام دهیم در نتیجه منطق ساخت در کل برنامه پخش می‌شود.
    </li>
    <li>
        الگوی Factory: این الگو فرآیند ساخت آبجکت‌های پیچیده را کپسوله می‌کند. با این کار کلاینت درگیر جزئیات ساخت و ست کردن استراتژی‌ها نمی‌شود. همچنین باعث می‌شود که سیستم نسبت به نوع دقیق تیکت‌هایی که ساخته می‌شوند اطلاعی نداشته باشد و در نتیجه وابستگی‌ها کم شود.
    </li>
    <li>
        ابتدا یک کلاس انتزاعی Abstract به نام TicketFactory تعریف می‌کنیم که متد createTicket را دارد. سپس برای هر کانال ورودی، زیرمجموعه می‌سازیم WebTicketFactory و EmailTicketFactory. این فکتوری‌ها وظیفه دارند تیکت را بسازند، استراتژی کانال مربوطه را به آن منتقل کنند و با توجه به نوع تیکت استراتژی پاسخ‌دهی درست را هم درون تیکت قرار دهند و در نهایت یک تیکت نهایی تحویل بدهند.
    </li>
</ol>



<h3 style="text-align: right;">State</h3>

<ol style="direction: rtl; text-align: right;">
  <li>
    درخواست های پشتیبانی هرکدام چند وضعیت متوالی دارند. درخواست ابتدا ایجاد شده سپس به بخش مربوطه ارجاع داده می‌شود و تا زمانی که کامل حل شود، در حالت "در حال رسیدگی" خواهد بود. سپس حل شده و درخواست بسته می‌شود.
  </li>
  <li>
    شی درخواست، وضعیت داخلی ‌اش تغییر کرده و با توجه به حالتی که در آن است، رفتارش متفاوت است. پس میتوانیم با الگوی State این قسمت را بازطراحی کنیم.
  </li>
  <li>
    برای اعمال این الگو، ابتدا باید یک interface به نام RequestState میسازیم که یک تابع Next() و PrintStatus() دارد. سپس برای هر حالت، یک کلاس میسازیم که از این interface، implement میکنند. کلاس هایی با نام createdState، assignedState، inProgressState ، ResolvedState و closedState. هر کدام از این کلاس ها تابع Next() را تغییر داده و حالت بعدی را فراخوانی میکنند و با متد PrintStatus() حالت خود را چاپ میکنند. Context این الگو نیز، کلاس Ticket است.
  </li>
</ol>











#بخش2)
<h3>   


<img width="1289" height="681" alt="Untitled Diagram drawio (3)" src="https://github.com/user-attachments/assets/c61424fe-9a84-4558-904f-d2a9758706ff" />




#بخش3)  

<h3>  

<h3>اصل SRP</h3>
<ol>
  <li>
    کلاس TicketService در ابتدا اصل SRP را نقض کرده بود؛ چراکه در این کلاس هم وضعیت درخواست بررسی می‌شد و همچنین انواع پاسخ‌ها و کانال‌ها مدیریت می‌شدند. این کلاس برخلاف اصل SRP که تأکید دارد هر کلاس فقط یک دلیل برای تغییر داشته باشد، دلایل متعددی برای تغییر داشت؛ از جمله زمانی که نیاز به اضافه کردن وضعیت جدید، نوع پاسخ جدید یا کانال جدید وجود داشت. پس از اعمال تغییرات و استفاده از الگوهای State و Strategy، کلاس TicketService اصل SRP را رعایت می‌کند.
  </li>
</ol>

<h3>اصل LSP</h3>
<ol>
  <li>
    قبل از اعمال الگو، با توجه به نبود abstraction، اصل LSP قابل بررسی نبود. پس از اعمال الگو و اضافه کردن abstraction، این اصل برقرار شده است. به‌عنوان مثال، در interface RequestState هر جا که از نوع RequestState استفاده شود، می‌توان AssignedState را جایگزین کرد؛ زیرا متدهای تعریف‌شده در interface را پیاده‌سازی کرده و رفتار غیرمنتظره یا تغییر‌یافته‌ای ندارد.
  </li>
</ol>

<h3>اصل ISP</h3>
<ol>
  <li>
    قبل از اعمال الگو، به دلیل نبود interface، اصل ISP قابل بررسی نبود. پس از اعمال الگو و اضافه کردن interface، این اصل به‌صورت کلی برقرار است. هرچند ممکن است به نظر برسد با توجه به اینکه برخی Stateها به متدهای Next یا PrintState نیازی ندارند، اصل ISP تا حدی نقض شده است، اما با در نظر گرفتن سادگی پیاده‌سازی الگوی State و ابعاد پروژه، این تصمیم آگاهانه بوده و نیازی به جداسازی interfaceها وجود ندارد.
  </li>
</ol>

<h3>اصل PLK</h3>
<ol>
  <li>
    کلاس TicketService در ابتدا این اصل را نقض کرده بود؛ زیرا دانش و وابستگی زیادی نسبت به جزئیات داخلی کلاس Ticket داشت. این کلاس نام فیلدها و همچنین انواع وضعیت‌ها، کانال‌ها و پاسخ‌ها را مستقیماً می‌شناخت و منطق مربوط به آن‌ها را مدیریت می‌کرد. پس از اعمال الگو، کلاس TicketService دیگر به جزئیات داخلی Ticket دسترسی مستقیم ندارد و تنها از طریق متدهای سطح بالای آن با شیء تعامل می‌کند. در نتیجه، میزان وابستگی و آگاهی آن نسبت به ساختار داخلی Ticket کاهش یافته و اصل PLK تا حد زیادی رعایت شده است.
  </li>
</ol>
