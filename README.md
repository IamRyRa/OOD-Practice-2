# OOD-Practice-2
#بخش1)
<h3>                                                                                                                                                                          Strategy</h3>

<ol>
    <li>
        در سیستم ما دو مورد وجود دارد که به روش‌های مختلفی انجام می‌شوند: مورد اول نحوه دریافت تیکت که بستگی به کانال ورودی دارد که می‌تواند از طریق وب یا ایمیل دریافت شود و مورد دوم نحوه پاسخ‌دهی است که به نوع تیکت (باگ یا درخواست عمومی) بستگی دارد. در کد اولیه، این‌ها با دستورات if-else از هم جدا شده بودند.
    </li>
    <li>
        الگوی Strategy: روش‌های مختلف برای پاسخ‌دهی داریم که روش‌های مختلف را در کلاس‌های جداگانه کپسوله می‌کنیم و اگر در آینده بخواهیم کانال جدیدی (مثل پیامک) یا نوع تیکت جدیدی اضافه کنیم، نیازی به تغییر در کدهای قبلی و بدنه اصلی سیستم نیست و فقط یک کلاس جدید می‌سازیم.
    </li>
    <li>
        اینترفیس به نام‌های ChannelStrategy و ResponseStrategy هر کدام جداگانه برای دو بخش مختلف تعریف می‌کنیم. برای هر روش یک کلاس جداگانه می‌سازیم. کلاس‌های WebChannelStrategy و EmailChannelStrategy برای بخش کانال، و کلاس‌های BugResponseStrategy و GenericResponseStrategy برای بخش پاسخ‌دهی. کلاس‌های State بدون اینکه بدانند نوع تیکت چیست فقط متد اجرای استراتژی را صدا می‌زنند.
    </li>
</ol>
<h3>Factory</h3>

<ol>
    <li>
        ایجاد یک آبجکت تیکت در سیستم ما پیچیده است چون تیکت بلافاصله بعد از ساخته شدن باید بداند از چه کانالی آمده و چه نوع استراتژی پاسخ‌دهی به آن تعلق می‌گیرد. اگر این کار را مستقیم در Main انجام دهیم در نتیجه منطق ساخت در کل برنامه پخش می‌شود.
    </li>
    <li>
        الگوی Factory: این الگو فرآیند ساخت آبجکت‌های پیچیده را کپسوله می‌کند. با این کار کلاینت درگیر جزئیات ساخت و ست کردن استراتژی‌ها نمی‌شود. همچنین باعث می‌شود که سیستم نسبت به نوع دقیق تیکت‌هایی که ساخته می‌شوند اطلاعی نداشته باشد و در نتیجه وابستگی‌ها کم شود.
    </li>
    <li>
        ابتدا یک کلاس انتزاعی Abstract به نام TicketFactory تعریف می‌کنیم که متد createTicket را دارد. سپس برای هر کانال ورودی، زیرمجموعه می‌سازیم WebTicketFactory و EmailTicketFactory. این فکتوری‌ها وظیفه دارند تیکت را بسازند، استراتژی کانال مربوطه را به آن منتقل کنند و با توجه به نوع تیکت استراتژی پاسخ‌دهی درست را هم درون تیکت قرار دهند و در نهایت یک تیکت نهایی تحویل بدهند.
    </li>
</ol>



<h3 style="text-align: right;">State</h3>

<ol style="direction: rtl; text-align: right;">
  <li>
    درخواست های پشتیبانی هرکدام چند وضعیت متوالی دارند. درخواست ابتدا ایجاد شده سپس به بخش مربوطه ارجاع داده می‌شود و تا زمانی که کامل حل شود، در حالت "در حال رسیدگی" خواهد بود. سپس حل شده و درخواست بسته می‌شود.
  </li>
  <li>
    شی درخواست، وضعیت داخلی ‌اش تغییر کرده و با توجه به حالتی که در آن است، رفتارش متفاوت است. پس میتوانیم با الگوی State این قسمت را بازطراحی کنیم.
  </li>
  <li>
    برای اعمال این الگو، ابتدا باید یک interface به نام RequestState میسازیم که یک تابع Next() و PrintStatus() دارد. سپس برای هر حالت، یک کلاس میسازیم که از این interface، implement میکنند. کلاس هایی با نام createdState، assignedState، inProgressState ، ResolvedState و closedState. هر کدام از این کلاس ها تابع Next() را تغییر داده و حالت بعدی را فراخوانی میکنند و با متد PrintStatus() حالت خود را چاپ میکنند. Context این الگو نیز، کلاس Ticket است.
  </li>
</ol>











#بخش2)
<h3>   


<img width="1289" height="681" alt="Untitled Diagram drawio (3)" src="https://github.com/user-attachments/assets/c61424fe-9a84-4558-904f-d2a9758706ff" />

