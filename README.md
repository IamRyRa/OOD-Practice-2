# OOD-Practice-2
#بخش1)
<h3>                                                                                                                                                                          Strategy</h3>

<ol>
    <li>
        در سیستم ما دو مورد وجود دارد که به روش‌های مختلفی انجام می‌شوند: مورد اول نحوه دریافت تیکت که بستگی به کانال ورودی دارد که می‌تواند از طریق وب یا ایمیل دریافت شود و مورد دوم نحوه پاسخ‌دهی است که به نوع تیکت (باگ یا درخواست عمومی) بستگی دارد. در کد اولیه، این‌ها با دستورات if-else از هم جدا شده بودند.
    </li>
    <li>
        الگوی Strategy: روش‌های مختلف برای پاسخ‌دهی داریم که روش‌های مختلف را در کلاس‌های جداگانه کپسوله می‌کنیم و اگر در آینده بخواهیم کانال جدیدی (مثل پیامک) یا نوع تیکت جدیدی اضافه کنیم، نیازی به تغییر در کدهای قبلی و بدنه اصلی سیستم نیست و فقط یک کلاس جدید می‌سازیم.
    </li>
    <li>
        اینترفیس به نام‌های ChannelStrategy و ResponseStrategy هر کدام جداگانه برای دو بخش مختلف تعریف می‌کنیم. برای هر روش یک کلاس جداگانه می‌سازیم. کلاس‌های WebChannelStrategy و EmailChannelStrategy برای بخش کانال، و کلاس‌های BugResponseStrategy و GenericResponseStrategy برای بخش پاسخ‌دهی. کلاس‌های State بدون اینکه بدانند نوع تیکت چیست فقط متد اجرای استراتژی را صدا می‌زنند.
    </li>
</ol>
<h3>Factory</h3>

<ol>
    <li>
        ایجاد یک آبجکت تیکت در سیستم ما پیچیده است چون تیکت بلافاصله بعد از ساخته شدن باید بداند از چه کانالی آمده و چه نوع استراتژی پاسخ‌دهی به آن تعلق می‌گیرد. اگر این کار را مستقیم در Main انجام دهیم در نتیجه منطق ساخت در کل برنامه پخش می‌شود.
    </li>
    <li>
        الگوی Factory: این الگو فرآیند ساخت آبجکت‌های پیچیده را کپسوله می‌کند. با این کار کلاینت درگیر جزئیات ساخت و ست کردن استراتژی‌ها نمی‌شود. همچنین باعث می‌شود که سیستم نسبت به نوع دقیق تیکت‌هایی که ساخته می‌شوند اطلاعی نداشته باشد و در نتیجه وابستگی‌ها کم شود.
    </li>
    <li>
        ابتدا یک کلاس انتزاعی Abstract به نام TicketFactory تعریف می‌کنیم که متد createTicket را دارد. سپس برای هر کانال ورودی، زیرمجموعه می‌سازیم WebTicketFactory و EmailTicketFactory. این فکتوری‌ها وظیفه دارند تیکت را بسازند، استراتژی کانال مربوطه را به آن منتقل کنند و با توجه به نوع تیکت استراتژی پاسخ‌دهی درست را هم درون تیکت قرار دهند و در نهایت یک تیکت نهایی تحویل بدهند.
    </li>
</ol>



<h3 style="text-align: right;">State</h3>

<ol style="direction: rtl; text-align: right;">
  <li>
    درخواست های پشتیبانی هرکدام چند وضعیت متوالی دارند. درخواست ابتدا ایجاد شده سپس به بخش مربوطه ارجاع داده می‌شود و تا زمانی که کامل حل شود، در حالت "در حال رسیدگی" خواهد بود. سپس حل شده و درخواست بسته می‌شود.
  </li>
  <li>
    شی درخواست، وضعیت داخلی ‌اش تغییر کرده و با توجه به حالتی که در آن است، رفتارش متفاوت است. پس میتوانیم با الگوی State این قسمت را بازطراحی کنیم.
  </li>
  <li>
    برای اعمال این الگو، ابتدا باید یک interface به نام RequestState میسازیم که یک تابع Next() و PrintStatus() دارد. سپس برای هر حالت، یک کلاس میسازیم که از این interface، implement میکنند. کلاس هایی با نام createdState، assignedState، inProgressState ، ResolvedState و closedState. هر کدام از این کلاس ها تابع Next() را تغییر داده و حالت بعدی را فراخوانی میکنند و با متد PrintStatus() حالت خود را چاپ میکنند. Context این الگو نیز، کلاس Ticket است.
  </li>
</ol>











#بخش2)
<h3>   


<img width="1289" height="681" alt="Untitled Diagram drawio (3)" src="https://github.com/user-attachments/assets/c61424fe-9a84-4558-904f-d2a9758706ff" />




#بخش3)  

<h3>  

<h3>اصل SRP</h3>
<ol>
  <li>
    کلاس TicketService در ابتدا اصل SRP را نقض کرده بود؛ چراکه در این کلاس هم وضعیت درخواست بررسی می‌شد و همچنین انواع پاسخ‌ها و کانال‌ها مدیریت می‌شدند. این کلاس برخلاف اصل SRP که تأکید دارد هر کلاس فقط یک دلیل برای تغییر داشته باشد، دلایل متعددی برای تغییر داشت؛ از جمله زمانی که نیاز به اضافه کردن وضعیت جدید، نوع پاسخ جدید یا کانال جدید وجود داشت. پس از اعمال تغییرات و استفاده از الگوهای State و Strategy، کلاس TicketService اصل SRP را رعایت می‌کند.
  </li>
</ol>



<h3>اصل OCP</h3>
<p>
   در کد قبلی با کوچکترین تغییر، کل TicketService باید ویرایش می‌شد. برای اضافه کردن یک نوع تیکت باید در متد handle شرط‌های جدید می‌نوشتیم اما با اعمال الگوی Strategy برای اضافه کردن نوع تیکت جدید فقط یک کلاس جدید را می‌سازیم که ResponseStrategy را پیاده‌سازی می‌کند. در کد قبلی اگر وضعیتی جدید (مثلاً وضعیتی بین Assigned و InProgress به نام Pending) اضافه می‌شد کل ساختار ifها در سرویس باید بازنویسی میشد با الگوی State یک کلاس جدید به نام PendingState می‌سازیم و ارجاع وضعیت را در کلاس قبل از آن تغییر می‌دهیم در نتیجه کلاس TicketService متوجه این تغییر نمی‌شود و بدون تغییر باقی می‌ماند.
  در کد قبلی اگر روش ارتباطی جدیدی (مثلاً پیامک) اضافه می‌شد باید کد ساخت تیکت در سراسر برنامه تغییر می‌کرد اما با اعمال الگوی factory فقط یک SMSTicketFactory اضافه می‌کنیم.
    سیستم بدون تغییر کلاس‌های موجود و فقط با اضافه کردن کلاس جدید قابلیت گسترش می‌یابد اما تعداد کلاس‌های پروژه زیاد شده است که برای سیستم‌های کوچک ممکن است overhead ایجاد کند.
</p>









<h3>اصل LSP</h3>
<ol>
  <li>
    قبل از اعمال الگو، با توجه به نبود abstraction، اصل LSP قابل بررسی نبود. پس از اعمال الگو و اضافه کردن abstraction، این اصل برقرار شده است. به‌عنوان مثال، در interface RequestState هر جا که از نوع RequestState استفاده شود، می‌توان AssignedState را جایگزین کرد؛ زیرا متدهای تعریف‌شده در interface را پیاده‌سازی کرده و رفتار غیرمنتظره یا تغییر‌یافته‌ای ندارد.
  </li>
</ol>

<h3>اصل ISP</h3>
<ol>
  <li>
    قبل از اعمال الگو، به دلیل نبود interface، اصل ISP قابل بررسی نبود. پس از اعمال الگو و اضافه کردن interface، این اصل به‌صورت کلی برقرار است. هرچند ممکن است به نظر برسد با توجه به اینکه برخی Stateها به متدهای Next یا PrintState نیازی ندارند، اصل ISP تا حدی نقض شده است، اما با در نظر گرفتن سادگی پیاده‌سازی الگوی State و ابعاد پروژه، این تصمیم آگاهانه بوده و نیازی به جداسازی interfaceها وجود ندارد.
  </li>
</ol>

<h3>اصل DIP</h3>
<p>
    در کد قبلی کلاس سطح بالای TicketService مستقیم به جزئیات سطح پایین وابسته بود.با استفاده از الگوی Strategy کلاس Ticket و State ها به اینترفیس‌های انتزاعی ChannelStrategy و ResponseStrategy وابسته هستند.
و با استفاده از الگوی State کلاس TicketService دیگر به منطق داخلیِ وضعیت‌ها وابسته نیست و فقط با اینترفیس RequestState تعامل داردو با استفاده از الگوی Factory کلاس Main دیگر به سازنده کلاس Ticket وابسته نیست، بلکه به TicketFactory وابسته است. این باعث می‌شود جزئیات ساخت تیکت از دیدِ سطح بالای برنامه پنهان بماند.
</p>


<h3>اصل PLK</h3>
<ol>
  <li>
    کلاس TicketService در ابتدا این اصل را نقض کرده بود؛ زیرا دانش و وابستگی زیادی نسبت به جزئیات داخلی کلاس Ticket داشت. این کلاس نام فیلدها و همچنین انواع وضعیت‌ها، کانال‌ها و پاسخ‌ها را مستقیماً می‌شناخت و منطق مربوط به آن‌ها را مدیریت می‌کرد. پس از اعمال الگو، کلاس TicketService دیگر به جزئیات داخلی Ticket دسترسی مستقیم ندارد و تنها از طریق متدهای سطح بالای آن با شیء تعامل می‌کند. در نتیجه، میزان وابستگی و آگاهی آن نسبت به ساختار داخلی Ticket کاهش یافته و اصل PLK تا حد زیادی رعایت شده است.
      </li>
</ol>

      
<h3>اصل CRP</h3>
<p>
در کلاس Ticket به جای اینکه برای انواع تیکت از وراثت و ایجاد کلاس‌های فرزند استفاده کنیم کلاس Ticket را با اینترفیس‌های ChannelStrategy و ResponseStrategy ترکیب کردیم</strong> که باعث می‌شود تا تیکت در زمان اجرا بتواند استراتژی‌ها و وضعیت‌های خود را بدون نیاز به تغییر ساختار کلاس عوض کند.
</p>
  </li>
</ol>
